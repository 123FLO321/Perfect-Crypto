//
//  Accessibility.swift
//  PerfectCrypto
//
//  Created by Jonathan Guthrie on 2017-08-23.
//

/// Provides a wrapper around the PerfectCrypto functions that give easy encryption/decryption with deterministic salts.
extension String {

	public func encrypt(password: String, _ cipher: Cipher = .aes_256_cbc) -> String {

		// String -> to bytes/UINT8
		let bytes = uint8Array()

		// The key value for the encrypt/decrypt
		// pad password/key to key length
		let key = pad(password.uint8Array(), cipher.keyLength)

		// Initialization vector
		let iv = [UInt8](randomCount: cipher.ivLength)

		// encrypt, then base64 encode response string
		var encrypted: [UInt8] = iv
		for i in bytes.encrypt(cipher, key: key, iv: iv) ?? [UInt8]() {
			encrypted.append(i)
		}

		let hexBytes = encrypted.encode(.base64)
		return String(validatingUTF8: hexBytes ?? [UInt8]()) ?? ""
	}

	public func decrypt(password: String, _ cipher: Cipher = .aes_256_cbc) -> String {
		let d1 = uint8Array()
		let data = d1.decode(.base64) ?? [UInt8]()

		// key, padded to correct length
		let key = pad(password.uint8Array(), cipher.keyLength)

		// initialization vector. taken from first x ofencrypted data
		var iv = [UInt8]()
		for i in 0..<(cipher.keyLength - 1) {
			iv.append(data[i])
		}
		// now remove
		let x = data.dropFirst(cipher.ivLength)

		// make sure it's a [Uint8], not what is generated by drop
		var encrypted = [UInt8]()
		for i in x { encrypted.append(i) }
		// decrypt
		let decrypted = encrypted.decrypt(cipher, key: key, iv: iv)
		//return
		return String(validatingUTF8: decrypted ?? [UInt8]()) ?? ""
	}

	private func uint8Array() -> [UInt8] {
		let r: [UInt8] = Array(self.utf8)
		return r
	}
	private func pad(_ i: [UInt8], _ length: Int) -> [UInt8]{
		var key = i
		for _ in 0..<(length - i.count){ key.append(UInt8(0)) }
		return key
	}
}

